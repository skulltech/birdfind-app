drop table if exists campaign cascade;
create table campaign (
    id bigint generated by default as identity primary key,
    created_at timestamp with time zone not null default now(),
    updated_at timestamp with time zone not null default now(),

    -- Campaign details
    name text not null,
    user_id uuid references auth.users not null,
    keywords text[] not null,
    
    -- Campaign view, i.e. sort, filters, etc.
    view jsonb not null default '{}',

    -- Status
    latest_tweet_id bigint references tweet,
    paused boolean not null default false,
    deleted boolean not null default false
);

create trigger on_campaign_updated
  before update on campaign
  for each row execute procedure set_updated_at();

alter table campaign enable row level security;

create policy "Users can insert their own campaigns."
  on campaign for insert
  to authenticated
  with check ( auth.uid() = user_id );

create policy "Users can view their own campaigns."
  on campaign for select
  to authenticated
  using ( auth.uid() = user_id );

create policy "Users can update their own campaigns."
  on campaign for update
  to authenticated
  using ( auth.uid() = user_id );

alter publication supabase_realtime add table campaign;

-- Campaign x Entity association table

drop table if exists campaign_entity cascade;
create table campaign_entity (
    campaign_id bigint references campaign on delete cascade not null,
    entity_id bigint references entity not null,
    primary key (campaign_id, entity_id)
);

alter table campaign_entity enable row level security;

create policy "Users can insert entities to their own campaigns."
  on campaign_entity for insert
  to authenticated
  with check (
      auth.uid() in (
      select campaign.user_id from campaign
      where campaign_entity.campaign_id = campaign.id
  ));;

create policy "Users can view entities of their own campaigns."
  on campaign_entity for select
  using (
      auth.uid() in (
      select campaign.user_id from campaign
      where campaign_entity.campaign_id = campaign.id
  ));

create policy "Users can update entities of their own campaigns."
  on campaign_entity for update
  using (
      auth.uid() in (
      select campaign.user_id from campaign
      where campaign_entity.campaign_id = campaign.id
  ));

-- Rate limit information

drop table if exists twitter_api_rate_limit cascade;
create table twitter_api_rate_limit (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default now() not null,

  twitter_id bigint references twitter_profile not null,
  endpoint text not null check (endpoint in ('lookup-tweets', 'tweets-recent-search')),
  
  resets_at timestamp with time zone not null
);

alter table twitter_api_rate_limit enable row level security;


-- Get campaign results

drop function if exists get_campaign_results(bigint) cascade;
create function get_campaign_results(campaign_id bigint) returns setof twitter_profile as $$

select distinct twitter_profile.* from

twitter_profile
  left join tweet on tweet.author_id = twitter_profile.id
  left join tweet_entity on tweet_entity.tweet_id = tweet.id

where tweet.text ~* array_to_string((select keywords from campaign where campaign.id = 6), '|')
  or tweet_entity.entity_id in (select entity_id from campaign_entity where campaign_id = 6)
;

$$ language sql;
